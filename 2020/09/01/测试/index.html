<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="#斗地主残局破解之设计文档##系统的功能分配  第一个是半自动破解残局的功能。输入获得的手牌，计算出将要出的手牌是什么。 第二个是自动破解残局功能。识别出双方的手牌，然后计算出将要出的手牌，接着控制鼠标点击和移动，并且可以根据设置的在出牌阶段以外点击其他的设置好的地方。 第三个是鼠标重复点击的功能。可以添加一些位置，然后设置一些时间和次数，按照这些参数来控制鼠标点击某些位置。这个功能是第二个功能的">
<meta property="og:type" content="article">
<meta property="og:title" content="测试">
<meta property="og:url" content="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="讨厌鬼和暴力猪猪的恋爱笔记">
<meta property="og:description" content="#斗地主残局破解之设计文档##系统的功能分配  第一个是半自动破解残局的功能。输入获得的手牌，计算出将要出的手牌是什么。 第二个是自动破解残局功能。识别出双方的手牌，然后计算出将要出的手牌，接着控制鼠标点击和移动，并且可以根据设置的在出牌阶段以外点击其他的设置好的地方。 第三个是鼠标重复点击的功能。可以添加一些位置，然后设置一些时间和次数，按照这些参数来控制鼠标点击某些位置。这个功能是第二个功能的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/pictrue/%E5%8D%8A%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/pictrue/%E5%85%A8%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B%E5%9B%BE.png">
<meta property="og:image" content="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/pictrue/%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E6%A1%86%E6%9E%B6.png">
<meta property="article:published_time" content="2020-09-01T03:14:48.000Z">
<meta property="article:modified_time" content="2020-09-01T04:46:04.784Z">
<meta property="article:author" content="讨厌鬼哦">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/pictrue/%E5%8D%8A%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B%E5%9B%BE.png">

<link rel="canonical" href="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>测试 | 讨厌鬼和暴力猪猪的恋爱笔记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">讨厌鬼和暴力猪猪的恋爱笔记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/01/%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="讨厌鬼哦">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="讨厌鬼和暴力猪猪的恋爱笔记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          测试
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-01 11:14:48 / 修改时间：12:46:04" itemprop="dateCreated datePublished" datetime="2020-09-01T11:14:48+08:00">2020-09-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>#斗地主残局破解之设计文档<br>##系统的功能分配</p>
<ul>
<li>第一个是半自动破解残局的功能。输入获得的手牌，计算出将要出的手牌是什么。</li>
<li>第二个是自动破解残局功能。识别出双方的手牌，然后计算出将要出的手牌，接着控制鼠标点击和移动，并且可以根据设置的在出牌阶段以外点击其他的设置好的地方。</li>
<li>第三个是鼠标重复点击的功能。可以添加一些位置，然后设置一些时间和次数，按照这些参数来控制鼠标点击某些位置。这个功能是第二个功能的缩略版，所以只要不选择一个自动出牌的部分就能做到。下面做模块划分的时候就不再赘述了。<br>##依赖环境<br>Windows10系统</li>
</ul>
<p>Python需要的库：<br>cv2、aircv、PIL、pymouse、ctypes、time、PysimpleGui<br>##文件结构<br>color_get文件夹：包含判断颜色的文件<br>simulate文件夹：包含计算出牌的文件<br>pic文件夹：包含识别所需要的图片</p>
<p>SimpleGui:程序入口，UI界面<br>Confirm:识别手牌<br>Click:点击手牌和出牌按钮<br>ThreadingUi:用于并行防程序假死<br>MinMaxEngine:用于全自动模式的自动出牌，包含识别，计算和出牌<br>utils:一些工具</p>
<div STYLE="page-break-after: always;"></div>

<p>##模块划分<br>###半自动部分<br>半自动部分主要有：输入输出和计算模块<br>半自动部分的流程图如下：<br><img src="./pictrue/%E5%8D%8A%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="半自动流程图"><br>####输入输出模块<br>在开始阶段，需要用户将双方的牌输入，然后在来回出牌阶段，让用户输入对手的出牌，将获得的信息传递给计算模块。输出则需要根据计算模块的结果输出给用户。<br>####计算模块<br>在输入模块中获得双方手牌的信息之后，在计算模块中计算出接下来应该出的手牌，然后传递给输入输出模块。</p>
<div STYLE="page-break-after: always;"></div>

<p>###全自动部分<br>全自动部分主要有：输入模块、鼠标控制模块、图像识别模块、计算模块<br>自动出牌部分就是利用到了图像识别模块，计算模块和鼠标控制模块，功能分配中的第三点就可以选择不使用这个部分来实现。<br>全自动部分的流程图如下：<br><img src="./pictrue/%E5%85%A8%E8%87%AA%E5%8A%A8%E6%A8%A1%E5%9D%97%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="全自动流程图"><br>####输入模块<br>用户可以根据需要，选择是否使用计算模块，同时根据输入模块选择程序控制鼠标移动的时间，次数这类参数。并且需要和鼠标控制模块配合获得鼠标位置信息。</p>
<div STYLE="page-break-after: always;"></div>

<p>####鼠标控制模块<br>因为是全自动，所以鼠标需要控制的地方比较多：输入模块中返回点击的点的位置，出牌阶段需要根据图像识别模块给出的坐标信息和计算模块给出的出牌信息控制鼠标移动和点击操作。<br>####图像识别模块<br>图像识别模块需要识别双方的手牌，然后返回双方手牌的具体信息和位置信息，交给计算模块完成计算。<br>####计算模块<br>计算模块从图像识别模块中获得双方手牌信息，然后根据信息计算出接下来自己的出牌信息，将出牌信息返回给鼠标控制模块。<br>##程序的总体结构<br>程序的总体结构用模块来划分的话：</p>
<ul>
<li>首先是输入输出模块来判断选择的方式是半自动还是全自动<ul>
<li>如果是半自动模块的话，那么就用输入输出模块来确定双方的手牌，然后传递给计算模块，计算模块返回给输入输出模块应该出的手牌，然后循环直到游戏结束。</li>
<li>如果是全自动模块的话，那么先用输入模块和鼠标控制模块来确定鼠标将要点击的位置和时间,然后选择是否加入自动出牌部分。<ul>
<li>如果不加入自动出牌部分，则点击开始之后鼠标控制模块开始执行输入模块中设置好的鼠标点击的操作。</li>
<li>如果加入自动出牌部分，则点击开始之后，鼠标控制模块开始执行出牌阶段前的点击操作，然后图像识别模块开始识别双方的手牌，传递到计算模块，计算模块将结果传给鼠标控制模块，鼠标控制模块根据图像识别模块识别出的手牌位置选择出牌，然后图像识别模块再次识别对手出牌，然后传递给计算模块，循环一直到本局游戏结束。本剧游戏结束后，鼠标控制模块开始执行出牌阶段后的点击操作，然后根据输入模块中输入的次数循环。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>程序的总体结构如下图所示：<br><img src="./pictrue/%E7%A8%8B%E5%BA%8F%E6%A8%A1%E5%9D%97%E6%A1%86%E6%9E%B6.png" alt="程序总结结构"><br>##输入输出及接口设计<br>输入利用的是PySimpleGui库中的read函数。<br>输出利用的是PySimpleGui库中的popup函数。<br>接口设计如下（按模块划分）：<br>###半自动部分：<br>####输入输出模块：<br>#####format_input_cards（List cards)<br>cards为自然语言描述的一个手牌集合，输出为手牌的数字集合。利用此函数将输入的数据从自然语言描述的手牌集合转化为计算模块所需的数字代表的手牌集合。</p>
<div STYLE="page-break-after: always;"></div>

<p>#####format_output_cards_semi（List cards)<br>cards为数字描述的一个手牌集合，输出为自然语言描述的的手牌集合。利用此函数将输入的数据从计算模块输出的手牌集合转化为自然语言的手牌集合。<br>#####SecondGetFirstCards（List values）<br>values为read函数读出来的输入，然后调用format_input_cards转换为数字代表的手牌集合，输出为双方的数字手牌集合。利用这个函数可以将从read函数中得到的值转换成数字方便进行后续计算。<br>####计算模块：<br>#####ThreadSimulate(List lorder_cards,List farmer_cards,List farmer_move)<br>lorder_cards为自己的手牌所转换的数字集合，farmer_cards为对方手牌的数字集合，farmer_move为对手移动的手牌的数字集合，输出为自己应该出的手牌的数字集合。这个函数可以并行执行来防止假死，并且在计算的过程中是有多线程同时计算的。利用此函数可以从双方的手牌及出牌情况获得下一步的出牌。<br>###全自动部分：<br>####输入模块：<br>#####AddClick(str button,List values)<br>输入为read函数读出来的输入，这个输入包含了每个位置停留的时间，输出为两个List,一个是位置，一个是停留的时间。利用这个函数可以添加一个位置在位置和时间序列中。<br>#####CancelClick（）<br>将AddClick添加的上一个位置的信息从序列中删去。<br>#####AddEngine（）<br>修改一个bool变量的值，添加自动出牌部分或者取消自动出牌部分。<br>####图像识别模块：<br>#####get_color(image)<br>输入为一张图片，输出为红色或者黑色。用于判断手牌中大小王的颜色来识别是大王还是小王。<br>#####confirm_own(bbox)<br>输入为识别的范围，输出为识别出的自己的手牌序列，以及各个手牌的位置。手牌的位置用于出牌时点击。<br>#####confirm_pos(bbox)<br>输入为识别的范围，输出为识别出的对手的手牌序列。不需要手牌的位置。两个函数的输出不同，所以分开写。<br>####计算模块：<br>#####start_engine(List lorder_cards,List farmer_cards，List farmer_move)<br>和半自动部分的计算模块相同，只不过不能并行执行。因为半自动模块在执行的过程中有窗口界面，所以并行执行以防止假死，而在全自动部分中，没有窗口便不用并行执行，但是依然在计算的过程中使用了多线程同时计算。<br>####鼠标控制模块：<br>#####ClickChosen(List pos,List timelist)<br>输入为两个序列，是AddClick函数的两个序列。根据这两个序列，鼠标将会根据这两个序列依次点击保存的点。<br>#####click_move(List cards_remove,List cards,List cards_click)<br>用于自动出牌部分。输入为start_engine返回的需要出牌的序列，还有confirm_own返回的自己手牌的序列和位置。利用此函数，可以实现根据cards_remove，点击自己的对应手牌。<br>#####ClickPassOrPlay(path,bbox)<br>用于自动出牌部分。输入为要识别的图像，以及要识别的范围。利用这个函数，可以找到识别的范围中要识别的图像，然后点击识别出来的位置的中央。主要用于点击牌局中的“出牌”和“不要”。<br>##函数具体实现<br>###半自动部分：<br>####输入输出模块：<br>#####format_input_cards（List cards)<br>    def format_input_cards(cards):#用于转换字符到数字<br>        return sorted([s2v[i] if i in s2v else i for i in cards])<br>转换成数字列表之后排序之后返回。<br>#####format_output_cards_semi（List cards)<br>    def format_output_cards_semi(cards):#用于转换数字到字符<br>        return sorted([v2s[i] if i in v2s else i for i in cards])<br>转换成字符列表之后排序之后返回。<br>#####SecondGetFirstCards（List values）<br>    def SecondGetFirstCards(self,values):#将输入到UI界面的自然语言的字符串转换成数字格式<br>        lorder_cards = values[0].split()#分割输入的字符串<br>        farmer_cards = values[1].split()<br>        lorder_cards = format_input_cards(lorder_cards)#调用来转换成数字格式<br>        farmer_cards = format_input_cards(farmer_cards)<br>        return lorder_cards,farmer_cards<br>将UI界面中输入的手牌转换成数字格式。先分割然后调用上面的函数。<br>####计算模块：<br>#####ThreadSimulate(List lorder_cards,List farmer_cards,List farmer_move)<br>    def ThreadSimulate(self,lorder_cards, farmer_cards, farmer_move):<br>        thread = MyThead(lorder_cards, farmer_cards, farmer_move)#实例化一个多线程类<br>        thread.start()#开启多线程<br>        while thread.get_result() == None:#一直尝试获得结果<br>            time_show()#进度条<br>        lorder_move = thread.get_result()<br>        return  lorder_move</p>
<pre><code>class MyThead (threading.Thread):
    def __init__(self, lorder_cards,farmer_cards,farmer_move):
        super(MyThead, self).__init__()
        #self.n = n
        self.lorder_cards=lorder_cards
        self.farmer_cards=farmer_cards
        self.farmer_move=farmer_move
        self.lorder_move=None
    def run(self):#调用start_engine这个函数
        self.lorder_move = start_engine(lorder_cards=self.lorder_cards,
                                farmer_cards=self.farmer_cards,
                                farmer_move=self.farmer_move)

    def get_result(self):#出结果后才会有具体的值
        try:
            return self.lorder_move
        except Exception:
            return None</code></pre>
<p>###全自动部分：<br>####输入模块：<br>#####AddClick(str button,List values)<br>    def AddClick(self,button,values):<br>        time.sleep(0.5)<br>        if button == ‘Add click before’:#自动出牌部分前点击<br>            self.flag_before_or_after = True<br>            self.time_before.append(values[0])<br>        else: #自动出牌部分后点击<br>            self.flag_before_or_after = False<br>            self.time_after.append(values[1])<br>        tmp_pos = (0, 0)<br>        while self.m.position() != 0:<br>            if tmp_pos == self.m.position():#当鼠标不动的时候，就会返回<br>                if button == ‘Add click before’:<br>                    self.pos_before.append(tmp_pos)<br>                else:<br>                    self.pos_after.append(tmp_pos)<br>                sg.popup(“you have chose the position” + str(tmp_pos))<br>                self.window1.FindElement(‘last’).update(‘you last chose ‘ + str(tmp_pos))<br>                break<br>            else:#当鼠标在动的时候，就每0.5s保存一个现在鼠标的位置<br>                tmp_pos = self.m.position()<br>                time.sleep(0.5)<br>主要算法是通过一段时间内鼠标不在移动来选择一个点。<br>#####CancelClick（）<br>    def CancelClick(self):<br>        #根据上一个是在自动出牌前还是后来选择位置和时间序列，然后去掉最后一个点<br>        if self.flag_before_or_after == True and self.pos_before != []:<br>            self.pos_before.pop()<br>            self.time_before.pop()<br>        elif self.flag_before_or_after == False and self.pos_after != []:<br>            self.pos_after.pop()<br>            self.time_after.pop()<br>根据上一个是在自动出牌前还是后来选择位置和时间序列，然后去掉最后一个点<br>#####AddEngine（）<br>    def AddEngine(self):<br>        #这个bool变量为false的时候就没有自动出牌，true就有自动出牌<br>        if self.flag_to_choose_the_engine == False:<br>            self.flag_to_choose_the_engine = True<br>        else:<br>            self.flag_to_choose_the_engine = False<br>        self.window1.FindElement(‘flag’).update(‘you have choose the engine:’ + str(self.flag_to_choose_the_engine))<br>####图像识别模块：<br>#####get_color(image)</p>
<pre><code>def get_color(frame):# 判断图片颜色
    print(&#39;go in get_color&#39;)
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    maxsum = -100
    color = None
    color_dict = colorList.getColorList()
    for d in color_dict:
        mask = cv2.inRange(hsv, color_dict[d][0], color_dict[d][1])
        cv2.imwrite(file_path+d + &#39;.jpg&#39;, mask)
        binary = cv2.threshold(mask, 127, 255, cv2.THRESH_BINARY)[1]
        binary = cv2.dilate(binary, None, iterations=2)
        img, cnts, hiera = cv2.findContours(binary.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        sum = 0
        for c in cnts:
            sum += cv2.contourArea(c)
        if sum &gt; maxsum:
            maxsum = sum
            color = d

    return color</code></pre>
<p>这个是在网上现有的轮子，便没有太多注释。<br>#####confirm_own(bbox)<br>    def confirm_own(bbox):<br>        own_card=[]<br>        own_card_click=[]<br>        card_list=[‘3’,’4’,’5’,’6’,’7’,’8’,’9’,’10’,’J’,’Q’,’K’,’A’,’2’]#识别的手牌种类<br>        im_confirm_own = ImageGrab.grab(bbox)#截图<br>        im_confirm_own.save(‘./pic/pro/confirm_own.jpg’)<br>        imsrc_confirm_own = ac.imread(‘./pic/pro/confirm_own.jpg’)#用aircv读取这张图片</p>
<pre><code>    path_card=&#39;./pic/card/&#39;#文件夹目录
    for card in card_list:
        imsch_confirm_own=ac.imread(path_card+card+&#39;.jpg&#39;)
        result_confirm=ac.find_all_template(imsrc_confirm_own,imsch_confirm_own,0.85)#0.85的参数是经过调试出来的
        #aircv的函数，因为一种牌不止有一张，便使用查找所有符合的图像
        if result_confirm != []:
            for i in range (len(result_confirm)):
                split=re.split(&#39;[.]&#39;,card)
                own_card.append(split[0])
                own_card_click.append(result_confirm[i][&#39;result&#39;])

    path_J = &#39;./pic/card_j/OWN/J.jpg&#39;#因为无法判断颜色，所以大小王无法识别，要单独识别
    imsch_confirm_own=ac.imread(path_J)
    result_confirm=ac.find_all_template(imsrc_confirm_own,imsch_confirm_own,0.95)#大小王比较精准，需要更高的相似度
    if result_confirm != []:
        for result in result_confirm:
            bbox_J=(bbox_confirm_own[0]+result[&#39;result&#39;][0]-50,
                    bbox_confirm_own[1]+result[&#39;result&#39;][1]-100,
                    bbox_confirm_own[0]+result[&#39;result&#39;][0]+50,
                    bbox_confirm_own[1]+result[&#39;result&#39;][1]+100)
            im_confirm_J=ImageGrab.grab(bbox_J)#因为get_color需要输入的是一张图片，要截图查找到的大小王位置附近
            im_confirm_J.save(&#39;./pic/color_test/J.jpg&#39;)
            im_confirm_J=cv2.imread(&#39;./pic/color_test/J.jpg&#39;)
            if get_color(im_confirm_J) == &#39;black&#39;:
                own_card.append(&#39;SJ&#39;)
                own_card_click.append(result[&#39;result&#39;])
            elif get_color(im_confirm_J) ==&#39;red&#39;:
                own_card.append(&#39;BJ&#39;)
                own_card_click.append(result[&#39;result&#39;])
    own_card = format_input_cards(own_card)#将手牌转换成数字格式
    return own_card,own_card_click</code></pre>
<p>主要是利用aircv库的函数还有get_color函数。<br>首先除了大小王其他的牌颜色并不会影响牌局，所以首先识别除了大小王其他的颜色。<br>然后再识别大小王。因为aircv里面的函数无法分辨颜色，便调用get_color函数，get_color函数需要一张图片作为输入，所以需要先找到大小王的位置，然后根据位置截图，然后将截图传给get_color函数，大王为红色，小王为黑色。然后就识别完了所有的自己的手牌。<br>其中aircv函数中的参数需要自己调试，根据结果选择一个比较合适的值。<br>#####confirm_pos(bbox)<br>和前一个函数大致相同，主要是函数的输出不同，所以不加赘述。<br>####计算模块：<br>#####start_engine(List lorder_cards,List farmer_cards，List farmer_move)<br>这个函数也是网上找的轮子的一部分,读懂运行逻辑后提取出来的。<br><a target="_blank" rel="noopener" href="https://github.com/FinixLei/WeChat_LandLords">github地址</a><br>主要思想是利用Min-Max引擎。在斗地主残局中，先出完牌的一方胜利。假设地主是先手方，在一轮出牌中一般有几种可选牌型，我们使用一个值来评估出这个牌型的”好坏“。能使地主获胜的为+1，使地主输牌的为-1。如果双方出牌都是最优的，那么在每一轮出牌中地主将极大化这个值，即从可选的牌型中打出最好的牌型，反之农民会极小化这个值，这就是MinMax。<br>####鼠标控制模块：<br>#####ClickChosen(List pos,List timelist)<br>    def ClickChosen(self,pos,timelist):<br>        for j in range(len(pos)):#根据位置和时间序列依次点击其中的点<br>            self.m.click(pos[j][0], pos[j][1])<br>            time.sleep(float(timelist[j]))<br>#####click_move(List cards_remove,List cards,List cards_click)<br>    def click_move(cards_remove,cards,cards_click):<br>        cards_remove = format_output_cards(cards_remove)#将数字类型的转换成字符串类型<br>        cards = format_output_cards(cards)<br>        m=PyMouse()#鼠标控制<br>        before_click=copy.deepcopy(cards)<br>        for card in cards_remove:<br>            remove_copy = copy.deepcopy(cards_remove)<br>            index_card=cards.index(card)<br>            del(cards[index_card])<br>            #鼠标点击对应的位置<br>            m.click(int((bbox_confirm_own[0]+cards_click[index_card][0])),int((bbox_confirm_own[1]+cards_click[index_card][1])))<br>            time.sleep(1)<br>            del(cards_click[index_card])</p>
<pre><code>        after_click,after_click_pos=confirm_own()#这个是因为斗地主游戏出牌阶段会自动补全出牌，所以出牌一次之后需要检查是否补全
        move=get_rest_cards(before_click,after_click)
        for i in move:
            remove_copy.remove(i)
        if remove_copy == []:
            return</code></pre>
<p>就是利用识别的时候保存的手牌序列及位置，根据要移动的手牌利用鼠标控制出牌。但是这个地方斗地主游戏会在出牌阶段自动补全，所以需要点击一张牌后就检查出牌，如果自动补全，则返回。<br>#####ClickPassOrPlay(path,bbox)<br>    def ClickPassOrPlay(path,bbox):<br>        m = PyMouse()<br>        im = ImageGrab.grab(bbox)#截图搜寻的区域<br>        # save jpg<br>        im.save(‘./pic/pro/desk.jpg’)<br>        imsrc = ac.imread(‘./pic/pro/desk.jpg’)  # 原始图像<br>        imsch = ac.imread(path)  # 待查找的部分<br>        result = ac.find_template(imsrc, imsch, 0.8)<br>        #因为只有一个地方需要点，所以不用find_all_template而是用find_template<br>        if result != None:<br>            #查找到之后就点击<br>            m.click(int((bbox[0] + result[‘result’][0])),<br>                    int((bbox[1] + result[‘result’][1])))<br>先截图待查找的地方，然后用aircv函数查找位置，因为只有一个地方需要点，所以不用find_all_template函数而是用find_template函数。查找到后就用鼠标控制来点击。<br>##出错处理设计</p>
<ol>
<li>在半自动模式中，输入的时候可以以空格间隔，也可以以逗号间隔，增加容错性</li>
<li>在半自动模式中，如果再对方出牌阶段输入了对方不存在的手牌，则会要求重新输入</li>
<li>在自动模式中，由于自动模式鲁棒性较差，如果出错，会弹出错误弹窗。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">讨厌鬼哦</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">1</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">讨厌鬼哦</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
